% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/setup.R
\name{fit_semiauto_abc}
\alias{fit_semiauto_abc}
\title{Tries to estimate the parameters through the semi-automatic approximate bayesian computation method: rejection sampling
but on a projected space given by a set of linear regressions rather than the original summary statistics space.
The prediction is the median of the posterior
and the interval of prediction is the posterior (cut at 2.5th and 97.5th quantiles)}
\usage{
fit_semiauto_abc(
  training_runs,
  target_runs,
  parameter_colnames,
  summary_statistics_colnames,
  tol = DEFAULT_TOL,
  degree = 1,
  ...
)
}
\arguments{
\item{training_runs}{A data.frame where each row represents a separate simulation run. The data.frame ought to
contain both the summary statistics (output of the model) and the parameters that generated them.}

\item{target_runs}{The "real" summary statistics for which we are trying to estimate which parameters generated them.
Target runs can be a data.frame with one or more rows of summary statistics and optionally also the generating parameters if we
are testing the estimation method. Alternatively a vector of length equal to the number of summary statistics}

\item{parameter_colnames}{The name of the columns in the training_runs data.frame that represent the parameters (inputs) of the
simulation model}

\item{summary_statistics_colnames}{The name of the columns in the training_runs data.frame that represent the summary statistics
(outputs) of the simulation model}

\item{tol}{tolerance error for ABC: in practice what % of the original runs end up forming the posterior (default is 0.1)}

\item{degree}{the degree of the linear regression that projects summary statistics to the space where ABC then takes place}

\item{\dots}{other arguments passed to the \code{abc::abc} method}
}
\value{
A list containing the basic estimation results
#' \itemize{
  \item predictions - The estimated values for each parameter (data.frame with as many rows as in \code{target_runs})
  \item lows - Estimated lower bound (2.5th quantile) for each estimated parameter (data.frame with as many rows as in \code{target_runs})
  \item highs - Estimated upper bound (97.5th quantile) for each estimated parameter (data.frame with as many rows as in \code{target_runs})
  \item prediction_residuals - Difference between "real" parameters and estimated ones for each row in the \code{target_runs};
  if target_runs didn't come with parameters, then only NAs are shown (data.frame with as many rows as in \code{target_runs})
  \item rmse - The root mean square error of the estimated parameter compared to the real one; only computed if target_runs also
  provided the real parameters otherwise NAs (named vector of length equal to the number of parameters)
  \item contained - The percentage of times the real parameters are contained in the estimated interval; NA if \code{target_runs}
  doesn't provide the real parameters (named vector of length equal to the number of parameters)
}
}
\description{
Tries to estimate the parameters through the semi-automatic approximate bayesian computation method: rejection sampling
but on a projected space given by a set of linear regressions rather than the original summary statistics space.
The prediction is the median of the posterior
and the interval of prediction is the posterior (cut at 2.5th and 97.5th quantiles)
}
\examples{
##generate some fake data where paramone,paramtwo ---> ssone,sswto;
## notice that paramtwo is basically unidentifiable!
paramone<-rnorm(n=5000)
paramtwo<-runif(n=5000,min=2,max=5)
ssone<-2*paramone + rnorm(n=5000)
sstwo<- paramone/paramtwo  + rnorm(n=5000)
training_data<-
  data.frame(
    paramone,
    paramtwo,
    ssone,
    sstwo
  )
  ## this would be the "real" data, what we want to estimate our model with!
testing_data<-data.frame(
  ssone=2,
 sstwo=0.25
)


### classic arguments: a data.frame for training and one for testing plus the column names
fit_semiauto_abc(training_runs = training_data,
                 target_runs =  testing_data,
                 parameter_colnames = c("paramone","paramtwo"),
                 summary_statistics_colnames = c("ssone","sstwo"),
                 degree = 1)
## you can fit just a vector of summary statistics (still need to provide the names though)

fit_semiauto_abc(training_runs = training_data,
                 target_runs =  c(2,1),
                 parameter_colnames = c("paramone","paramtwo"),
                 summary_statistics_colnames = c("ssone","sstwo"),
                 degree = 2)
## if you feed a full data.frame as target, especially with parameters included, you get error and coverage stuff

fit_semiauto_abc(training_runs = training_data,
                target_runs =  training_data,
                parameter_colnames = c("paramone","paramtwo"),
                summary_statistics_colnames = c("ssone","sstwo"),
                degree = 4)
)
}
